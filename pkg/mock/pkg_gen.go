// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"context"
	"github.com/aws/aws-sdk-go/aws/request"
	"github.com/aws/aws-sdk-go/service/s3"
	"github.com/aws/aws-sdk-go/service/sqs"
	"github.com/secmon-as-code/hatchery/pkg/interfaces"
	"net/http"
	"sync"
)

// Ensure, that HTTPClientMock does implement interfaces.HTTPClient.
// If this is not the case, regenerate this file with moq.
var _ interfaces.HTTPClient = &HTTPClientMock{}

// HTTPClientMock is a mock implementation of interfaces.HTTPClient.
//
//	func TestSomethingThatUsesHTTPClient(t *testing.T) {
//
//		// make and configure a mocked interfaces.HTTPClient
//		mockedHTTPClient := &HTTPClientMock{
//			DoFunc: func(req *http.Request) (*http.Response, error) {
//				panic("mock out the Do method")
//			},
//		}
//
//		// use mockedHTTPClient in code that requires interfaces.HTTPClient
//		// and then make assertions.
//
//	}
type HTTPClientMock struct {
	// DoFunc mocks the Do method.
	DoFunc func(req *http.Request) (*http.Response, error)

	// calls tracks calls to the methods.
	calls struct {
		// Do holds details about calls to the Do method.
		Do []struct {
			// Req is the req argument value.
			Req *http.Request
		}
	}
	lockDo sync.RWMutex
}

// Do calls DoFunc.
func (mock *HTTPClientMock) Do(req *http.Request) (*http.Response, error) {
	if mock.DoFunc == nil {
		panic("HTTPClientMock.DoFunc: method is nil but HTTPClient.Do was just called")
	}
	callInfo := struct {
		Req *http.Request
	}{
		Req: req,
	}
	mock.lockDo.Lock()
	mock.calls.Do = append(mock.calls.Do, callInfo)
	mock.lockDo.Unlock()
	return mock.DoFunc(req)
}

// DoCalls gets all the calls that were made to Do.
// Check the length with:
//
//	len(mockedHTTPClient.DoCalls())
func (mock *HTTPClientMock) DoCalls() []struct {
	Req *http.Request
} {
	var calls []struct {
		Req *http.Request
	}
	mock.lockDo.RLock()
	calls = mock.calls.Do
	mock.lockDo.RUnlock()
	return calls
}

// Ensure, that SQSMock does implement interfaces.SQS.
// If this is not the case, regenerate this file with moq.
var _ interfaces.SQS = &SQSMock{}

// SQSMock is a mock implementation of interfaces.SQS.
//
//	func TestSomethingThatUsesSQS(t *testing.T) {
//
//		// make and configure a mocked interfaces.SQS
//		mockedSQS := &SQSMock{
//			DeleteMessageWithContextFunc: func(ctx context.Context, input *sqs.DeleteMessageInput, opts ...request.Option) (*sqs.DeleteMessageOutput, error) {
//				panic("mock out the DeleteMessageWithContext method")
//			},
//			ReceiveMessageWithContextFunc: func(ctx context.Context, input *sqs.ReceiveMessageInput, opts ...request.Option) (*sqs.ReceiveMessageOutput, error) {
//				panic("mock out the ReceiveMessageWithContext method")
//			},
//		}
//
//		// use mockedSQS in code that requires interfaces.SQS
//		// and then make assertions.
//
//	}
type SQSMock struct {
	// DeleteMessageWithContextFunc mocks the DeleteMessageWithContext method.
	DeleteMessageWithContextFunc func(ctx context.Context, input *sqs.DeleteMessageInput, opts ...request.Option) (*sqs.DeleteMessageOutput, error)

	// ReceiveMessageWithContextFunc mocks the ReceiveMessageWithContext method.
	ReceiveMessageWithContextFunc func(ctx context.Context, input *sqs.ReceiveMessageInput, opts ...request.Option) (*sqs.ReceiveMessageOutput, error)

	// calls tracks calls to the methods.
	calls struct {
		// DeleteMessageWithContext holds details about calls to the DeleteMessageWithContext method.
		DeleteMessageWithContext []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Input is the input argument value.
			Input *sqs.DeleteMessageInput
			// Opts is the opts argument value.
			Opts []request.Option
		}
		// ReceiveMessageWithContext holds details about calls to the ReceiveMessageWithContext method.
		ReceiveMessageWithContext []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Input is the input argument value.
			Input *sqs.ReceiveMessageInput
			// Opts is the opts argument value.
			Opts []request.Option
		}
	}
	lockDeleteMessageWithContext  sync.RWMutex
	lockReceiveMessageWithContext sync.RWMutex
}

// DeleteMessageWithContext calls DeleteMessageWithContextFunc.
func (mock *SQSMock) DeleteMessageWithContext(ctx context.Context, input *sqs.DeleteMessageInput, opts ...request.Option) (*sqs.DeleteMessageOutput, error) {
	if mock.DeleteMessageWithContextFunc == nil {
		panic("SQSMock.DeleteMessageWithContextFunc: method is nil but SQS.DeleteMessageWithContext was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Input *sqs.DeleteMessageInput
		Opts  []request.Option
	}{
		Ctx:   ctx,
		Input: input,
		Opts:  opts,
	}
	mock.lockDeleteMessageWithContext.Lock()
	mock.calls.DeleteMessageWithContext = append(mock.calls.DeleteMessageWithContext, callInfo)
	mock.lockDeleteMessageWithContext.Unlock()
	return mock.DeleteMessageWithContextFunc(ctx, input, opts...)
}

// DeleteMessageWithContextCalls gets all the calls that were made to DeleteMessageWithContext.
// Check the length with:
//
//	len(mockedSQS.DeleteMessageWithContextCalls())
func (mock *SQSMock) DeleteMessageWithContextCalls() []struct {
	Ctx   context.Context
	Input *sqs.DeleteMessageInput
	Opts  []request.Option
} {
	var calls []struct {
		Ctx   context.Context
		Input *sqs.DeleteMessageInput
		Opts  []request.Option
	}
	mock.lockDeleteMessageWithContext.RLock()
	calls = mock.calls.DeleteMessageWithContext
	mock.lockDeleteMessageWithContext.RUnlock()
	return calls
}

// ReceiveMessageWithContext calls ReceiveMessageWithContextFunc.
func (mock *SQSMock) ReceiveMessageWithContext(ctx context.Context, input *sqs.ReceiveMessageInput, opts ...request.Option) (*sqs.ReceiveMessageOutput, error) {
	if mock.ReceiveMessageWithContextFunc == nil {
		panic("SQSMock.ReceiveMessageWithContextFunc: method is nil but SQS.ReceiveMessageWithContext was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Input *sqs.ReceiveMessageInput
		Opts  []request.Option
	}{
		Ctx:   ctx,
		Input: input,
		Opts:  opts,
	}
	mock.lockReceiveMessageWithContext.Lock()
	mock.calls.ReceiveMessageWithContext = append(mock.calls.ReceiveMessageWithContext, callInfo)
	mock.lockReceiveMessageWithContext.Unlock()
	return mock.ReceiveMessageWithContextFunc(ctx, input, opts...)
}

// ReceiveMessageWithContextCalls gets all the calls that were made to ReceiveMessageWithContext.
// Check the length with:
//
//	len(mockedSQS.ReceiveMessageWithContextCalls())
func (mock *SQSMock) ReceiveMessageWithContextCalls() []struct {
	Ctx   context.Context
	Input *sqs.ReceiveMessageInput
	Opts  []request.Option
} {
	var calls []struct {
		Ctx   context.Context
		Input *sqs.ReceiveMessageInput
		Opts  []request.Option
	}
	mock.lockReceiveMessageWithContext.RLock()
	calls = mock.calls.ReceiveMessageWithContext
	mock.lockReceiveMessageWithContext.RUnlock()
	return calls
}

// Ensure, that S3Mock does implement interfaces.S3.
// If this is not the case, regenerate this file with moq.
var _ interfaces.S3 = &S3Mock{}

// S3Mock is a mock implementation of interfaces.S3.
//
//	func TestSomethingThatUsesS3(t *testing.T) {
//
//		// make and configure a mocked interfaces.S3
//		mockedS3 := &S3Mock{
//			GetObjectWithContextFunc: func(ctx context.Context, input *s3.GetObjectInput, opts ...request.Option) (*s3.GetObjectOutput, error) {
//				panic("mock out the GetObjectWithContext method")
//			},
//		}
//
//		// use mockedS3 in code that requires interfaces.S3
//		// and then make assertions.
//
//	}
type S3Mock struct {
	// GetObjectWithContextFunc mocks the GetObjectWithContext method.
	GetObjectWithContextFunc func(ctx context.Context, input *s3.GetObjectInput, opts ...request.Option) (*s3.GetObjectOutput, error)

	// calls tracks calls to the methods.
	calls struct {
		// GetObjectWithContext holds details about calls to the GetObjectWithContext method.
		GetObjectWithContext []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Input is the input argument value.
			Input *s3.GetObjectInput
			// Opts is the opts argument value.
			Opts []request.Option
		}
	}
	lockGetObjectWithContext sync.RWMutex
}

// GetObjectWithContext calls GetObjectWithContextFunc.
func (mock *S3Mock) GetObjectWithContext(ctx context.Context, input *s3.GetObjectInput, opts ...request.Option) (*s3.GetObjectOutput, error) {
	if mock.GetObjectWithContextFunc == nil {
		panic("S3Mock.GetObjectWithContextFunc: method is nil but S3.GetObjectWithContext was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Input *s3.GetObjectInput
		Opts  []request.Option
	}{
		Ctx:   ctx,
		Input: input,
		Opts:  opts,
	}
	mock.lockGetObjectWithContext.Lock()
	mock.calls.GetObjectWithContext = append(mock.calls.GetObjectWithContext, callInfo)
	mock.lockGetObjectWithContext.Unlock()
	return mock.GetObjectWithContextFunc(ctx, input, opts...)
}

// GetObjectWithContextCalls gets all the calls that were made to GetObjectWithContext.
// Check the length with:
//
//	len(mockedS3.GetObjectWithContextCalls())
func (mock *S3Mock) GetObjectWithContextCalls() []struct {
	Ctx   context.Context
	Input *s3.GetObjectInput
	Opts  []request.Option
} {
	var calls []struct {
		Ctx   context.Context
		Input *s3.GetObjectInput
		Opts  []request.Option
	}
	mock.lockGetObjectWithContext.RLock()
	calls = mock.calls.GetObjectWithContext
	mock.lockGetObjectWithContext.RUnlock()
	return calls
}
