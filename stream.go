package hatchery

import (
	"context"

	"github.com/google/uuid"
	"github.com/m-mizutani/goerr"
)

type Streams []*Stream

func (s Streams) Validate() error {
	idSet := map[string]struct{}{}

	for _, stream := range s {
		if err := stream.Validate(); err != nil {
			return err
		}

		if _, ok := idSet[stream.id]; ok {
			return goerr.Wrap(ErrInvalidStream, "duplicated stream ID").With("id", stream.id)
		}

		idSet[stream.id] = struct{}{}
	}

	return nil
}

// Stream is a pipeline of data processing.
type Stream struct {
	src Source
	dst Destination

	id   string
	tags []string
}

type StreamOption func(*Stream)

// WithTags is an option to set tags to the stream.
func WithTags(tags ...string) StreamOption {
	return func(s *Stream) {
		s.tags = tags
	}
}

// WithID is an option to set ID to the stream. If not set, it will be generated by UUID.
func WithID(id string) StreamOption {
	return func(s *Stream) {
		s.id = id
	}
}

// NewStream creates a new Stream object with source and destination. It can be customized by options.
func NewStream(src Source, dst Destination, options ...StreamOption) *Stream {
	id, err := uuid.NewV7()
	if err != nil {
		// Fallback to UUID v4
		id = uuid.New()
	}
	s := &Stream{id: string(id.String()), src: src, dst: dst}

	for _, opt := range options {
		opt(s)
	}

	return s
}

// Run executes the stream, which invokes Source.Load and saves data via Destination.
func (x *Stream) Run(ctx context.Context) error {
	return x.src(ctx, NewPipe(x.dst))
}

// Validate checks the stream is valid or not.
func (x *Stream) Validate() error {
	if x.id == "" {
		return goerr.Wrap(ErrInvalidStream, "ID is not defined")
	}
	if x.src == nil {
		return goerr.Wrap(ErrInvalidStream, "source is not defined").With("id", x.id)
	}
	if x.dst == nil {
		return goerr.Wrap(ErrInvalidStream, "destination is not defined").With("id", x.id)
	}
	return nil
}
